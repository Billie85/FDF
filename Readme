チャレンジしてみたコード
探索法を使うことができるけど、3Dにする時に隙間ができて上手くいかない。
線をつなげてあげる部分で隙間ができていて、それに気づかないで。
3Dにした時に上手くいかなかったりしてしまう。
ブレゼンハムのアルゴリズムを使ってあがる事で隙間ができなくて上手に書くことだ出来る。
↓探索法を使ってみた。

/* void	isometric(float *x, float *y, int z)
{
	float angle;
	angle = 0.523;// π／６ isometricの定義
	*x = (*x - *y) * cos(angle);
	*y = (*x + *y) * sin(angle) - z;
}
 void	search_line(float x0, float y0, float x1, float y1, fdf *data)
{
	float dx, dy, p, x, y;
	int z;
	int z1;

	z = data->z_matrix[(int)y0][(int)x0];
	z1 = data->z_matrix[(int)y1][(int)x1];

//----------zoom----------
	x0 *= data->zoom;
	y0 *= data->zoom;
	x1 *= data->zoom;
	y1 *= data->zoom;
//----------color----------
if (z > 0 || z1 > 0)
{
	data->color = 0xe80c0c;
}
else
{
	data->color = 0xffffff;
}
//----------3D----------
isometric(&x0, &y0, z);
isometric(&x1, &y1, z1);

//----------shift----------
x0 += 300;
y0 += 300;
x1 += 300;
y1 += 300;

	x = x0;
	while(x <= x1)
	{
		if (x == x0 || x == x1)
		{
			y = y0;
			while(y <= y1)
			{
				mlx_pixel_put(data->mlx_ptr, data->win_ptr, x, y, data->color);
				y++;
			}
		}
			else
			{
				y = y0;
				if (y == y0 || y == y1)
				{
					x = x0;
					while(x <= x1)
					{
						mlx_pixel_put(data->mlx_ptr, data->win_ptr, x, y, data->color);
						x++;
					}
				}
			}
		x++;
	} */